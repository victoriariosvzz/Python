# -*- coding: utf-8 -*-
"""covid-19-vaccination-progress-regression.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1rHBuPzQEpVCyeh8DUlqyIOK5RaoGLezs

# Data preprocessing

## Importing the libraries
"""

import pandas as pd # to import the dataset
import numpy as np # to handle matrices
import matplotlib.pyplot as plt # to plot

"""## Importing the data"""

from google.colab import drive
drive.mount('/content/drive')

dataset = pd.read_csv("/content/drive/MyDrive/Colab Notebooks/Projects/Covid19 Vaccine Progress/country_vaccinations.csv")
dataset.head(10) # we check the first 10 rows of our dataset

dataset.columns # we read the column names

"""I want to predict the total vaccinations (y) based on the other features of the dataset (x), where x is my independent variable (in this case, more than one) and y is the dependent variable."""

x_df = dataset[['country', 'date','daily_vaccinations_raw', 'daily_vaccinations','total_vaccinations_per_hundred', 'people_vaccinated_per_hundred',
       'people_fully_vaccinated_per_hundred', 'daily_vaccinations_per_million','vaccines']] # independent variables
y_df = dataset[['total_vaccinations']] # dependent variable

x = x_df.values # as array
y = y_df.values # as array

x[0:10,:] # we check the first 10 rows of our array x

y[0:10,:] # we check the first 10 rows of our array y

"""## Taking care of missing data"""

from sklearn.impute import SimpleImputer # importing the SimpleImputer class that let's us replace the missing values 
                                         # with the average of the column

imputer = SimpleImputer(missing_values= np.nan, strategy="mean")

"""Applied to x:"""

imputer.fit(X = x[:, 2:8]) # expects only the numerical values columns, not the category ones

x[:,2:8] = imputer.transform(x[:,2:8]) # we replace the missing values on the original array
x[0:10,:]

"""Applied to y:"""

imputer.fit(X = y) # expects only the numerical values columns, not the category ones

y = imputer.transform(y) # we replace the missing values on the original array
y[0:10,:]

"""## Encoding categorical data"""

x_df = pd.DataFrame(x, columns = ['country', 'date','daily_vaccinations_raw', 'daily_vaccinations','total_vaccinations_per_hundred', 'people_vaccinated_per_hundred',
       'people_fully_vaccinated_per_hundred', 'daily_vaccinations_per_million','vaccines'])
x_df

x_df = pd.get_dummies(x_df, columns=["date","country", "vaccines"], prefix=["date","country", "vaccines"]) # now, x_df has the dummy variables

x_df.head() # we verify th structure with the dummy variables

x = x_df.values # convertind the data frame into an array
x

y

"""## Splitting the dataset into the Training set and Test set

Let's create our train and test arrays with 20% of the data corresponding to the test array.
"""

from sklearn.model_selection import train_test_split
x_train, x_test, y_train, y_test = train_test_split(x, y, test_size = 0.2, random_state = 1)

len(x_train) # verifying its size

len(x_test) # verifying its size

"""# Regression Model Application

## 1. **Multiple Linear Regression**

### Training the Multiple Linear Regression model on the Training set
"""

from sklearn.linear_model import LinearRegression

regressor = LinearRegression()
regressor.fit(x_train, y_train)

"""### Predicting the Test set results

We test the trained model with the test data and concatenate it in an array for easy comparison
"""

y_pred = regressor.predict(x_test)
np.set_printoptions(precision = 0)
print(np.concatenate((y_pred.reshape(len(y_pred),1), y_test.reshape(len(y_test),1)),1))

"""### Evaluating the Model Performance

We obtain an r squared of 0.82, meaning a fit of 82%
"""

from sklearn.metrics import r2_score
r2_score(y_test, y_pred)

"""## 2. Multiple Linear Regression

### Training the Polynomial Regression model on the Training set
"""

from sklearn.preprocessing import PolynomialFeatures
from sklearn.linear_model import LinearRegression

poly_reg = PolynomialFeatures(degree = 3)
x_poly = poly_reg.fit_transform(x_train)
regressor = LinearRegression()
regressor.fit(x_poly, y_train)

"""### Predicting the Test set results"""

y_pred = regressor.predict(poly_reg.transform(x_test))
np.set_printoptions(precision=2)
print(np.concatenate((y_pred.reshape(len(y_pred),1), y_test.reshape(len(y_test),1)),1))

"""### Evaluating the Model Performance"""

from sklearn.metrics import r2_score
r2_score(y_test, y_pred)